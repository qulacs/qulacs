<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Python Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Python Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>量子状態</h2>
<h3>量子状態の生成</h3>
<p>以下のコードで<code>n</code>qubitの量子状態を生成します。 生成した量子状態は <img class="formulaInl" alt="$|0\rangle^{\otimes n}$" src="form_0.png"/> に初期化されています。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line"># 5-qubitの状態を生成</div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line"></div><div class="line"># |00000&gt;に初期化</div><div class="line">state.set_zero_state()</div></div><!-- fragment --><p> メモリが不足している場合は量子状態を生成できません。</p>
<p>### 量子状態のデータの取得 量子状態を表す <img class="formulaInl" alt="$2^n$" src="form_1.png"/> の長さの配列を取得します。特にGPUで量子状態を作成したり、大きい <img class="formulaInl" alt="$n$" src="form_2.png"/> では非常に重い操作になるので注意してください。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line"># 状態ベクトルをnumpy arrayとして取得</div><div class="line">data = state.get_vector()</div><div class="line">print(data)</div></div><!-- fragment --><h3>量子状態の初期化</h3>
<p>生成した量子状態は、計算基底に初期化したり、ランダムな状態に初期化することが出来ます。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line"># |00101&gt;に初期化</div><div class="line">state.set_computational_basis(0b00101)</div><div class="line">print(state.get_vector())</div><div class="line"></div><div class="line"># ランダムな初期状態を生成</div><div class="line">state.set_Haar_random_state()</div><div class="line">print(state.get_vector())</div><div class="line"></div><div class="line"># シードを指定してランダムな初期状態を生成</div><div class="line">seed = 0</div><div class="line">state.set_Haar_random_state(seed)</div><div class="line">print(state.get_vector())</div></div><!-- fragment --><h3>量子状態のデータのコピーとロード</h3>
<p>量子状態を複製したり、他の量子状態のデータをロードできます。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_computational_basis(0b00101)</div><div class="line"></div><div class="line"># コピーして新たな量子状態を作成</div><div class="line">second_state = state.copy()</div><div class="line">print(second_state.get_vector())</div><div class="line"></div><div class="line"># 量子状態を新たに生成し、既存の状態のベクトルをコピー</div><div class="line">third_state = QuantumState(n)</div><div class="line">third_state.load(state)</div><div class="line">print(third_state.get_vector())</div></div><!-- fragment --><h3>古典レジスタの操作</h3>
<p>量子状態は古典レジスタを持っており、読み書きを行えます。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line"># 3rd classical registerに値1をセット</div><div class="line">register_position = 3</div><div class="line">register_value = 1</div><div class="line">state.set_classical_value(register_position, register_value)</div><div class="line"></div><div class="line"># 3rd classical registerの値を取得</div><div class="line">obtained_value = state.get_classical_value(register_position)</div><div class="line">print(obtained_value)</div></div><!-- fragment --><h3>量子状態に関する計算</h3>
<p>量子状態には種々の処理が可能です。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_Haar_random_state()</div><div class="line"></div><div class="line"># normの計算</div><div class="line">norm = state.get_norm()</div><div class="line">print(&quot;norm : &quot;,norm)</div><div class="line"></div><div class="line"># Z基底で測定した時のentropyの計算</div><div class="line">entropy = state.get_entropy() </div><div class="line">print(&quot;entropy : &quot;,entropy)</div><div class="line"></div><div class="line"># index-th qubitをZ基底で測定して0を得る確率の計算</div><div class="line">index = 3</div><div class="line">zero_probability = state.get_zero_probability(index)</div><div class="line">print(&quot;prob_meas_3rd : &quot;,zero_probability)</div><div class="line"></div><div class="line"># 周辺確率を計算 (以下は0,3-th qubitが0、1,2-th qubitが1と測定される確率の例)</div><div class="line">value_list = [0,1,1,0,2]</div><div class="line">marginal_probability = state.get_marginal_probability(value_list)</div><div class="line">print(&quot;marginal_prob : &quot;,marginal_probability)</div></div><!-- fragment --><h3>量子状態の内積</h3>
<p><code>inner_product</code>関数で内積を計算できます。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.state import inner_product</div><div class="line"></div><div class="line">n = 5</div><div class="line">state_bra = QuantumState(n)</div><div class="line">state_ket = QuantumState(n)</div><div class="line">state_bra.set_Haar_random_state()</div><div class="line">state_ket.set_computational_basis(0)</div><div class="line"></div><div class="line"># 内積値の計算</div><div class="line">value = inner_product(state_bra, state_ket)</div><div class="line">print(value)</div></div><!-- fragment --><h3>量子状態の解放</h3>
<p>delを用いて量子状態を強制的にメモリから解放することができます。 delせずとも利用されなくなったタイミングで解放されますが、メモリがシビアな際に便利です。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line"></div><div class="line"># 量子状態を開放</div><div class="line">del state</div></div><!-- fragment --><h3>量子状態の詳細情報の取得</h3>
<p>オブジェクトを直接printすると、量子状態の情報が出力されます。 </p><div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line"></div><div class="line">print(state)</div></div><!-- fragment --><h2>量子ゲート</h2>
<h3>量子ゲートの生成と作用</h3>
<p>デフォルトで実装されている量子ゲートはgateモジュールで定義されます。</p>
<div class="fragment"><div class="line">import numpy as np</div><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.gate import X, RY, DenseMatrix</div><div class="line"></div><div class="line">n = 3</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line">print(state.get_vector())</div><div class="line"></div><div class="line"># 1st-qubitにX操作</div><div class="line">index = 1</div><div class="line">x_gate = X(index)</div><div class="line">x_gate.update_quantum_state(state)</div><div class="line">print(state.get_vector())</div><div class="line"></div><div class="line"># 1st-qubitをYパウリでpi/4.0回転</div><div class="line">angle = np.pi / 4.0</div><div class="line">ry_gate = RY(index, angle)</div><div class="line">ry_gate.update_quantum_state(state)</div><div class="line">print(state.get_vector())</div><div class="line"></div><div class="line"># 2nd-qubitにゲート行列で作成したゲートを作用</div><div class="line">dense_gate = DenseMatrix(2, [[0,1],[1,0]])</div><div class="line">dense_gate.update_quantum_state(state)</div><div class="line">print(state.get_vector())</div><div class="line"></div><div class="line"># ゲートの解放</div><div class="line">del x_gate</div><div class="line">del ry_gate</div><div class="line">del dense_gate</div></div><!-- fragment --><p>事前に定義されているゲートは以下の通りです。</p><ul>
<li>single-qubit Pauli operation: Identity, X,Y,Z</li>
<li>single-qubit Clifford operation : H,S,Sdag, T,Tdag,sqrtX,sqrtXdag,sqrtY,sqrtYdag</li>
<li>two-qubit Clifford operation : CNOT, CZ, SWAP</li>
<li>single-qubit Pauli rotation : RX, RY, RZ</li>
<li>General Pauli operation : Pauli, PauliRotation</li>
<li>IBMQ basis-gate : U1, U2, U3</li>
<li>General gate : DenseMatrix</li>
<li>Measurement : Measurement</li>
<li>Noise : BitFlipNoise, DephasingNoise, IndepenedentXZNoise, DepolarizingNoise</li>
</ul>
<p>回転ゲートである<code>RX</code>,<code>RY</code>,<code>RZ</code>,<code>PauliRotation</code>は所定のパウリ演算子$P$について、引数$\theta$に対して$\exp(i\frac{\theta}{2}P)$という操作を行います。 それぞれのゲートの詳細はAPIドキュメントを参照してください。</p>
<h3>量子ゲートの合成</h3>
<p>続けて作用する量子ゲートを合成し、新たな単一の量子ゲートを生成できます。これにより量子状態へのアクセスを減らせます。 </p><div class="fragment"><div class="line">import numpy as np</div><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.gate import X, RY, merge</div><div class="line"></div><div class="line">n = 3</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line">index = 1</div><div class="line">x_gate = X(index)</div><div class="line">angle = np.pi / 4.0</div><div class="line">ry_gate = RY(index, angle)</div><div class="line"></div><div class="line"># ゲートを合成して新たなゲートを生成</div><div class="line"># 第一引数が先に作用する</div><div class="line">x_and_ry_gate = merge(x_gate, ry_gate)</div><div class="line">x_and_ry_gate.update_quantum_state(state)</div><div class="line">print(state.get_vector())</div></div><!-- fragment --><h3>量子ゲートのゲート行列の和</h3>
<p>量子ゲートのゲート要素の和を取ることができます。 (control-qubitがある場合の和は現状動作が未定義なので利用しないでください。) </p><div class="fragment"><div class="line">import numpy as np</div><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.gate import P0,P1,add, merge, Identity, X, Z</div><div class="line"></div><div class="line">gate00 = merge(P0(0),P0(1))</div><div class="line">gate11 = merge(P1(0),P1(1))</div><div class="line"># |00&gt;&lt;00| + |11&gt;&lt;11|</div><div class="line">proj_00_or_11 = add(gate00, gate11)</div><div class="line">print(proj_00_or_11)</div><div class="line"></div><div class="line">gate_ii_zz = add(Identity(0), merge(Z(0),Z(1)))</div><div class="line">gate_ii_xx = add(Identity(0), merge(X(0),X(1)))</div><div class="line">proj_00_plus_11 = merge(gate_ii_zz, gate_ii_xx)</div><div class="line"># ((|00&gt;+|11&gt;)(&lt;00|+&lt;11|))/2 = (II + ZZ)(II + XX)/4</div><div class="line">proj_00_plus_11.multiply_scalar(0.25)</div><div class="line">print(proj_00_plus_11)</div></div><!-- fragment --><h3>特殊な量子ゲートと一般の量子ゲート</h3>
<p>Qulacsにおける基本量子ゲートは以下の二つに分けられます。</p><ul>
<li>特殊ゲート：そのゲートの作用について、専用の高速化がなされた関数があるもの。</li>
<li>一般ゲート：ゲート行列を保持し、行列をかけて作用するもの。</li>
</ul>
<p>前者は後者に比べ専用の関数が作成されているため高速ですが、コントロール量子ビットを増やすなど、量子ゲートの作用を変更する操作が後から行えません。 こうした変更をしたい場合、特殊ゲートを一般ゲートに変換してやらねばなりません。 これは<code>gate.to_matrix_gate</code>で実現できます。以下がその例になります。</p>
<div class="fragment"><div class="line">import numpy as np</div><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.gate import to_matrix_gate, X</div><div class="line">n = 3</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line">index = 0</div><div class="line">x_gate = X(index)</div><div class="line">x_mat_gate = to_matrix_gate(x_gate)</div><div class="line"></div><div class="line"># 1st-qubitが0の場合だけゲートを作用</div><div class="line">control_index = 1</div><div class="line">control_with_value = 0</div><div class="line">x_mat_gate.add_control_qubit(control_index, control_with_value)</div><div class="line"></div><div class="line">x_mat_gate.update_quantum_state(state)</div><div class="line">print(state.get_vector())</div></div><!-- fragment --><h3>量子ゲートのゲート行列の取得</h3>
<p>生成した量子ゲートのゲート行列を取得できます。control量子ビットなどはゲート行列に含まれません。特にゲート行列を持たない種類のゲート（例えばn-qubitのパウリ回転ゲート）などは取得に非常に大きなメモリと時間を要するので気を付けてください。 </p><div class="fragment"><div class="line">import numpy as np</div><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.gate import X, RY, merge</div><div class="line"></div><div class="line">n = 3</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line">index = 1</div><div class="line">x_gate = X(index)</div><div class="line">angle = np.pi / 4.0</div><div class="line">ry_gate = RY(index, angle)</div><div class="line">x_and_ry_gate = merge(x_gate, ry_gate)</div><div class="line"></div><div class="line"># ゲート行列を取得</div><div class="line">matrix = x_and_ry_gate.get_matrix()</div><div class="line">print(matrix)</div></div><!-- fragment --><h3>量子ゲートの情報の取得</h3>
<p>printに流し込むことで、量子ゲートの情報を取得できます。行列要素をあらわに持つゲート(一般ゲート)の場合のみ、ゲート行列も表示されます。 </p><div class="fragment"><div class="line">from qulacs.gate import X, to_matrix_gate</div><div class="line">gate = X(0)</div><div class="line">print(gate)</div><div class="line">print(to_matrix_gate(gate))</div></div><!-- fragment --><h3>一般的な量子ゲートの実現</h3>
<p>Qulacsでは量子情報における種々のマップを以下の形で実現します。</p>
<h4>ユニタリ操作</h4>
<p>量子ゲートとして実現します。</p>
<h4>射影演算子やクラウス演算子など</h4>
<p>量子ゲートとして実現します。一般に作用後に量子状態のノルムは保存されません。<code>DenseMatrix</code>関数により生成できます。 </p><div class="fragment"><div class="line">from qulacs.gate import DenseMatrix</div><div class="line"></div><div class="line"># 1-qubit gateの場合</div><div class="line">gate = DenseMatrix(0, [[0,1],[1,0]])</div><div class="line">print(gate)</div><div class="line"></div><div class="line"># 2-qubit gateの場合</div><div class="line">gate = DenseMatrix([0,1], [[1,0,0,0],[0,1,0,0],[0,0,0,1],[0,0,1,0]])</div><div class="line">print(gate)</div></div><!-- fragment --><h4>確率的なユニタリ操作</h4>
<p><code>Probabilistic</code>関数を用いて、複数のユニタリ操作と確率分布を与えて作成します。</p>
<div class="fragment"><div class="line">from qulacs.gate import Probabilistic, X, Y</div><div class="line"></div><div class="line">distribution = [0.1, 0.2, 0.3]</div><div class="line">gate_list = [X(0), Y(0), X(1)]</div><div class="line">gate = Probabilistic(distribution, gate_list)</div></div><!-- fragment --><p> 確率の総和が1に満たない場合、残りの確率はIdentityの作用になります。</p>
<h4>CPTP-map</h4>
<p><code>CPTP</code>関数に完全性を満たすクラウス演算子のリストとして与えて作成します。</p>
<div class="fragment"><div class="line">from qulacs.gate import merge,CPTP, P0,P1</div><div class="line"></div><div class="line">gate00 = merge(P0(0),P0(1))</div><div class="line">gate01 = merge(P0(0),P1(1))</div><div class="line">gate10 = merge(P1(0),P0(1))</div><div class="line">gate11 = merge(P1(0),P1(1))</div><div class="line"></div><div class="line">gate_list = [gate00, gate01, gate10, gate11]</div><div class="line">gate = CPTP(gate_list)</div></div><!-- fragment --><h4>POVM</h4>
<p>数値計算上にはInstrumentと同じなので、Instrumentとして実現します。</p>
<h4>Instrument</h4>
<p>Instrumentは一般のCPTP-mapの操作に加え、ランダムに作用したクラウス演算子の添え字を取得する操作です。例えば、Z基底での測定は<code>P0</code>と<code>P1</code>からなるCPTP-mapを作用し、どちらが作用したかを知ることに相当します。 cppsimでは<code>Instrument</code>関数にCPTP-mapの情報と、作用したクラウス演算子の添え字を書きこむ古典レジスタのアドレスを指定することで実現します。</p>
<div class="fragment"><div class="line">from qulacs import QuantumState</div><div class="line">from qulacs.gate import merge,Instrument, P0,P1</div><div class="line"></div><div class="line">gate00 = merge(P0(0),P0(1))</div><div class="line">gate01 = merge(P0(0),P1(1))</div><div class="line">gate10 = merge(P1(0),P0(1))</div><div class="line">gate11 = merge(P1(0),P1(1))</div><div class="line"></div><div class="line">gate_list = [gate00, gate01, gate10, gate11]</div><div class="line">classical_pos = 0</div><div class="line">gate = Instrument(gate_list, classical_pos)</div><div class="line"></div><div class="line">state = QuantumState(2)</div><div class="line">state.set_Haar_random_state()</div><div class="line"></div><div class="line">print(state)</div><div class="line">gate.update_quantum_state(state)</div><div class="line">result = state.get_classical_value(classical_pos)</div><div class="line">print(state)</div><div class="line">print(result)</div></div><!-- fragment --><ul>
<li>Adaptive 古典レジスタに書き込まれた値を用いた条件に応じて操作を行うか決定します。 条件はpythonの関数として記述することができます。pythonの関数は<code>unsigned int</code>型のリストを引数として受け取り、<code>bool</code>型を返す関数でなくてはなりません。</li>
</ul>
<div class="fragment"><div class="line">from qulacs.gate import Adaptive, X</div><div class="line"></div><div class="line">def func(list):</div><div class="line">    return list[0]==1</div><div class="line">gate = Adaptive(X(0), func)</div><div class="line"></div><div class="line">state = QuantumState(2)</div><div class="line">state.set_Haar_random_state()</div><div class="line"></div><div class="line"># func returns False, and gate is not applied</div><div class="line">gate.set_classical_value(0,0)</div><div class="line">gate.update_quantum_state(state)</div><div class="line"></div><div class="line"># func returns True, and gate is applied</div><div class="line">gate.set_classical_value(0,1)</div><div class="line">gate.update_quantum_state(state)</div></div><!-- fragment --><h4>CP-map</h4>
<p>Kraus-rankが1の場合は、上記の単体のクラウス演算子として扱ってください。それ以外の場合は、TPになるようにクラウス演算子を調整した後、<code>multiply_scalar</code>関数で定数倍にした<code>Identity</code>オペレータを作用するなどして調整してください。</p>
<h2>量子回路</h2>
<h3>量子回路の構成</h3>
<p>量子回路は量子ゲートの集合として表されます。 例えば以下のように量子回路を構成できます。</p>
<div class="fragment"><div class="line">from qulacs import QuantumState, QuantumCircuit</div><div class="line">from qulacs.gate import Z</div><div class="line">n = 5</div><div class="line">state = QuantumState(n)</div><div class="line">state.set_zero_state()</div><div class="line"></div><div class="line"># 量子回路を定義</div><div class="line">circuit = QuantumCircuit(n)</div><div class="line"></div><div class="line"># 量子回路にhadamardゲートを追加</div><div class="line">for i in range(n):</div><div class="line">    circuit.add_H_gate(i)</div><div class="line"></div><div class="line"># ゲートを生成し、それを追加することもできる。</div><div class="line">for i in range(n):</div><div class="line">    circuit.add_gate(Z(i))</div><div class="line"></div><div class="line"># 量子回路を状態に作用</div><div class="line">circuit.update_quantum_state(state)</div><div class="line"></div><div class="line">print(state.get_vector())</div></div><!-- fragment --><p>なお、<code>add_gate</code>で追加された量子回路は量子回路の解放時に一緒に解放されます。従って、代入したゲートは再利用できません。引数として与えたゲートを再利用したい場合はgate.copyを用いて自身のコピーを作成するか、&lt;code&gt;add_gate_copy関数を用いてください。</p>
<h3>量子回路のdepthの計算と最適化</h3>
<p>量子ゲートをまとめて一つの量子ゲートとすることで、量子ゲートの数を減らすことができ、数値計算の時間を短縮できることがあります。（もちろん、対象となる量子ビットの数が増える場合や、専用関数を持つ量子ゲートを合成して専用関数を持たない量子ゲートにしてしまった場合は、トータルで計算時間が減少するかは状況に依ります。）</p>
<p>下記のコードでは<code>optimize</code>関数を用いて、量子回路の量子ゲートをターゲットとなる量子ビットが3つになるまで貪欲法で合成を繰り返します。</p>
<div class="fragment"><div class="line">from qulacs import QuantumCircuit</div><div class="line">from qulacs.circuit import QuantumCircuitOptimizer</div><div class="line">n = 5</div><div class="line">depth = 10</div><div class="line">circuit = QuantumCircuit(n)</div><div class="line">for d in range(depth):</div><div class="line">    for i in range(n):</div><div class="line">        circuit.add_H_gate(i)</div><div class="line"></div><div class="line"># depthを計算(depth=10)</div><div class="line">print(circuit.calculate_depth())</div><div class="line"></div><div class="line"># 最適化</div><div class="line">opt = QuantumCircuitOptimizer()</div><div class="line"># 作成を許す最大の量子ゲートのサイズ</div><div class="line">max_block_size = 1</div><div class="line">opt.optimize(circuit, max_block_size)</div><div class="line"></div><div class="line"># depthを計算(depth=1へ)</div><div class="line">print(circuit.calculate_depth())</div></div><!-- fragment --><h3>量子回路の情報デバッグ</h3>
<p>量子回路をprintすると、量子回路に含まれるゲートの統計情報などが表示されます。</p>
<div class="fragment"><div class="line">from qulacs import QuantumCircuit</div><div class="line">from qulacs.circuit import QuantumCircuitOptimizer</div><div class="line">n = 5</div><div class="line">depth = 10</div><div class="line">circuit = QuantumCircuit(n)</div><div class="line">for d in range(depth):</div><div class="line">    for i in range(n):</div><div class="line">        circuit.add_H_gate(i)</div><div class="line">print(circuit)</div></div><!-- fragment --><h2>オブザーバブル</h2>
<h3>オブザーバブルの生成</h3>
<p>オブザーバブルはパウリ演算子の集合として表現されます。 パウリ演算子は下記のように定義できます。 </p><div class="fragment"><div class="line">from qulacs import Observable</div><div class="line">n = 5</div><div class="line">coef = 2.0</div><div class="line"># 2.0 X_0 X_1 Y_2 Z_4というパウリ演算子を設定</div><div class="line">Pauli_string = &quot;X 0 X 1 Y 2 Z 4&quot;</div><div class="line">observable = Observable(n)</div><div class="line">observable.add_operator(coef,Pauli_string)</div></div><!-- fragment --><h3>オブザーバブルの評価</h3>
<p>状態に対してオブザーバブルの期待値を評価できます。 </p><div class="fragment"><div class="line">from qulacs import Observable, QuantumState</div><div class="line"></div><div class="line">n = 5</div><div class="line">coef = 2.0</div><div class="line">Pauli_string = &quot;X 0 X 1 Y 2 Z 4&quot;</div><div class="line">observable = Observable(n)</div><div class="line">observable.add_operator(coef,Pauli_string)</div><div class="line"></div><div class="line">state = QuantumState(n)</div><div class="line">state.set_Haar_random_state()</div><div class="line"># 期待値の計算</div><div class="line">value = observable.get_expectation_value(state)</div><div class="line">print(value)</div></div><!-- fragment --><h2>変分量子回路</h2>
<p>量子回路をParametricQuantumCircuitクラスとして定義すると、通所のQuantumCircuitクラスの関数に加え、変分法を用いて量子回路を最適化するのに便利ないくつかの関数を利用することができます。</p>
<h3>変分量子回路の利用例</h3>
<p>一つの回転角を持つ量子ゲート(X-rot, Y-rot, Z-rot, multi_qubit_pauli_rotation)はパラメトリックな量子ゲートとして量子回路に追加することができます。パラメトリックなゲートとして追加された量子ゲートについては、量子回路の構成後にパラメトリックなゲート数を取り出したり、後から回転角を変更することができます。</p>
<div class="fragment"><div class="line">from qulacs import ParametricQuantumCircuit</div><div class="line">from qulacs import QuantumState</div><div class="line">import numpy as np</div><div class="line"></div><div class="line">n = 5</div><div class="line">depth = 10</div><div class="line"></div><div class="line"># construct parametric quantum circuit with random rotation</div><div class="line">circuit = ParametricQuantumCircuit(n)</div><div class="line">for d in range(depth):</div><div class="line">    for i in range(n):</div><div class="line">        angle = np.random.rand()</div><div class="line">        circuit.add_parametric_RX_gate(i,angle)</div><div class="line">        angle = np.random.rand()</div><div class="line">        circuit.add_parametric_RY_gate(i,angle)</div><div class="line">        angle = np.random.rand()</div><div class="line">        circuit.add_parametric_RZ_gate(i,angle)</div><div class="line">    for i in range(d%2, n-1, 2):</div><div class="line">        circuit.add_CNOT_gate(i,i+1)</div><div class="line"></div><div class="line"># add multi-qubit Pauli rotation gate as parametric gate (X_0 Y_3 Y_1 X_4)</div><div class="line">target = [0,3,1,4]</div><div class="line">pauli_ids = [1,2,2,1]</div><div class="line">angle = np.random.rand()</div><div class="line">circuit.add_parametric_multi_Pauli_rotation_gate(target, pauli_ids, angle)</div><div class="line"></div><div class="line"># get variable parameter count, and get current parameter</div><div class="line">parameter_count = circuit.get_parameter_count()</div><div class="line">param = [circuit.get_parameter(ind) for ind in range(parameter_count)]</div><div class="line"></div><div class="line"># set 3rd parameter to 0</div><div class="line">circuit.set_parameter(3, 0.)</div><div class="line"></div><div class="line"># update quantum state</div><div class="line">state = QuantumState(n)</div><div class="line">circuit.update_quantum_state(state)</div><div class="line"></div><div class="line"># output state and circuit info</div><div class="line">print(state)</div><div class="line">print(circuit)</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
