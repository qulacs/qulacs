<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C++ Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">C++ Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>量子状態</h2>
<h3>量子状態の生成</h3>
<p>以下のコードで<code>n</code>qubitの量子状態を生成します。 生成した量子状態は <img class="formulaInl" alt="$|0\rangle^{\otimes n}$" src="form_0.png"/> に初期化されています。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="comment">// 5-qubitの状態を生成</span></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    <span class="comment">// |00000&gt;に初期化</span></div><div class="line">    state.set_zero_state();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> メモリが不足している場合はプログラムが終了します。</p>
<h3>量子状態の初期化</h3>
<p>生成した量子状態は、計算基底に初期化したり、ランダムな状態に初期化することが出来ます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> test() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line">    <span class="comment">// |00101&gt;に初期化</span></div><div class="line">    state.set_computational_basis(0b00101);</div><div class="line">    <span class="comment">// ランダムな初期状態を生成</span></div><div class="line">    state.set_Haar_random_state();</div><div class="line">    <span class="comment">// シードを指定してランダムな初期状態を生成</span></div><div class="line">    state.set_Haar_random_state(0);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>量子状態のデータのコピーとロード</h3>
<p>量子状態を複製したり、他の量子状態のデータをロードできます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_computational_basis(0b00101);</div><div class="line"></div><div class="line">    <span class="comment">// コピーして新たな量子状態を作成</span></div><div class="line">    <span class="keyword">auto</span> second_state = state.copy();</div><div class="line"></div><div class="line">    <span class="comment">// 量子状態を新たに生成し、既存の状態のベクトルをコピー</span></div><div class="line">    QuantumState third_state(n);</div><div class="line">    third_state.load(&amp;state);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>古典レジスタの操作</h3>
<p>量子状態は古典レジスタを持っており、読み書きを行えます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="comment">// registerの書き込み</span></div><div class="line">    <span class="keywordtype">int</span> register_position = 3;</div><div class="line">    <span class="keywordtype">int</span> register_value = 1;</div><div class="line">    state.set_classical_bit(register_position, register_value);</div><div class="line"></div><div class="line">    <span class="comment">// registerの読み出し</span></div><div class="line">    <span class="keywordtype">int</span> obtained_value;</div><div class="line">    obtained_value = state.get_classical_bit(register_position);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>量子状態に関する計算</h3>
<p>量子状態を変えない計算として、以下の処理が可能です。 量子状態を変える計算は必ず量子ゲート、量子回路を介して行われます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line">    </div><div class="line">    <span class="comment">// normの計算</span></div><div class="line">    <span class="keywordtype">double</span> norm = state.get_norm(); </div><div class="line">    <span class="comment">// Z基底で測定した時のentropyの計算</span></div><div class="line">    <span class="keywordtype">double</span> entropy = state.get_entropy(); </div><div class="line"></div><div class="line">    <span class="comment">// index-th qubitをZ基底で測定して0を得る確率の計算</span></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keywordtype">double</span> zero_prob = state.get_zero_prob(index);</div><div class="line"></div><div class="line">    <span class="comment">// 周辺確率を計算 (以下は0,3-th qubitが0、1,2-th qubitが1と測定される確率の例)</span></div><div class="line">    std::vector&lt;unsigned int&gt; value_list = {0,1,1,0,2};</div><div class="line">    <span class="keywordtype">double</span> marginal_prob = state.get_marginal_prob(value_list);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>量子状態の内積</h3>
<p><code>inner_product</code>関数で内積を計算できます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state_ket(n);</div><div class="line">    state_ket.set_zero_state();</div><div class="line"></div><div class="line">    QuantumState state_bra(n);</div><div class="line">    state_bra.set_Haar_random_state();</div><div class="line"></div><div class="line">    std::complex&lt;double&gt; value = state::inner_product(&amp;state_ket, &amp;state_bra);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>### 量子状態のデータの取得 量子状態を表す <img class="formulaInl" alt="$2^n$" src="form_1.png"/> の長さの配列を取得します。 特にGPUで量子状態を作成したり、大きい <img class="formulaInl" alt="$n$" src="form_2.png"/> では非常に重い操作になるので注意してください。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="comment">// GNU C++の場合、double _Complex配列を取得</span></div><div class="line">    <span class="comment">// MSVCの場合はstd::complex&lt;double&gt;の配列を取得</span></div><div class="line">    <span class="keyword">const</span> CTYPE* raw_data_c = state.data_c();</div><div class="line"></div><div class="line">    <span class="comment">// std::complex&lt;double&gt;の配列を取得</span></div><div class="line">    <span class="keyword">const</span> CPPCTYPE* raw_data_cpp = state.data_cpp();</div><div class="line">}</div></div><!-- fragment --><p>量子状態を直接指定の配列にセットしたい場合などは、該当する量子ゲートを作成し、量子ゲートの作用として行うことを推奨します。</p>
<h2>量子ゲート</h2>
<h3>量子ゲートの生成と作用</h3>
<p>デフォルトで実装されている量子ゲートはgate_factoryの関数を通じて生成され、量子状態のポインタを引数として作用させられます。gate_factoryで生成した量子ゲートは自動では解放されないため、ユーザが解放しなければいけません。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="comment">// Xゲートの作用</span></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> x_gate = gate::X(index);</div><div class="line">    x_gate-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="comment">// YでのPI/2回転</span></div><div class="line">    <span class="keywordtype">double</span> angle = M_PI / 2.0;</div><div class="line">    <span class="keyword">auto</span> ry_gate = gate::RY(index, angle);</div><div class="line">    ry_gate-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> x_gate;</div><div class="line">    <span class="keyword">delete</span> ry_gate;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p><code>gate</code>名前空間で定義されているゲートは以下の通りです。</p><ul>
<li>single-qubit Pauli operation: Identity, X,Y,Z</li>
<li>single-qubit Clifford operation : H,S,Sdag, T,Tdag,sqrtX,sqrtXdag,sqrtY,sqrtYdag</li>
<li>two-qubit Clifford operation : CNOT, CZ, SWAP</li>
<li>single-qubit Pauli rotation : RX, RY, RZ</li>
<li>General Pauli operation : Pauli, PauliRotation</li>
<li>IBMQ basis-gate : U1, U2, U3</li>
<li>General gate : DenseMatrix</li>
<li>Measurement : Measurement</li>
<li>Noise : BitFlipNoise, DephasingNoise, IndepenedentXZNoise, DepolarizingNoise</li>
</ul>
<h3>量子ゲートの合成</h3>
<p>量子ゲートを合成し、新たな量子ゲートを生成できます。 合成したゲートは自身で解放しなければいけません。 </p><div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> x_gate = gate::X(index);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> angle = M_PI / 2.0;</div><div class="line">    <span class="keyword">auto</span> ry_gate = gate::RY(index, angle);</div><div class="line"></div><div class="line">    <span class="comment">// X, RYの順番に作用するゲートの作成</span></div><div class="line">    <span class="keyword">auto</span> x_and_ry_gate = gate::merge(x_gate, ry_gate);</div><div class="line"></div><div class="line">    x_and_ry_gate-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> x_gate;</div><div class="line">    <span class="keyword">delete</span> ry_gate;</div><div class="line">    <span class="keyword">delete</span> x_and_ry_gate;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>量子ゲートのゲート行列の和</h3>
<p>量子ゲートのゲート要素の和を取ることができます。 (control-qubitがある場合の和は現状動作が未定義なので利用しないでください。) </p><div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> gate00 = gate::merge(gate::P0(0), gate::P0(1));</div><div class="line">    <span class="keyword">auto</span> gate11 = gate::merge(gate::P1(0), gate::P1(1));</div><div class="line">    <span class="comment">// |00&gt;&lt;00| + |11&gt;&lt;11|</span></div><div class="line">    <span class="keyword">auto</span> proj_00_or_11 = gate::add(gate00, gate11);</div><div class="line">    std::cout &lt;&lt; proj_00_or_11 &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> gate_ii_zz = gate::add(gate::Identity(0), gate::merge(gate::Z(0), gate::Z(1)));</div><div class="line">    <span class="keyword">auto</span> gate_ii_xx = gate::add(gate::Identity(0), gate::merge(gate::X(0), gate::X(1)));</div><div class="line">    <span class="keyword">auto</span> proj_00_plus_11 = gate::merge(gate_ii_zz, gate_ii_xx);</div><div class="line">    <span class="comment">// ((|00&gt;+|11&gt;)(&lt;00|+&lt;11|))/2 = (II + ZZ)(II + XX)/4</span></div><div class="line">    proj_00_plus_11-&gt;multiply_scalar(0.25);</div><div class="line">    std::cout &lt;&lt; proj_00_plus_11 &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>特殊な量子ゲートと一般の量子ゲート</h3>
<p>cppsimにおける基本量子ゲートは以下の二つに分けられます。</p><ul>
<li>特殊ゲート：そのゲートの作用について、専用の高速化がなされた関数があるもの。</li>
<li>一般ゲート：ゲート行列を保持し、行列をかけて作用するもの。</li>
</ul>
<p>前者は後者に比べ専用の関数が作成されているため高速ですが、コントロール量子ビットを増やすなど、量子ゲートの作用を変更する操作が後から行えません。 こうした変更をしたい場合、特殊ゲートを一般ゲートに変換してやらねばなりません。</p>
<p>これは<code>gate::convert_to_matrix_gate</code>で実現できます。 以下がその例になります。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> x_gate = gate::X(index);</div><div class="line"></div><div class="line">    <span class="comment">// 1st-qubitが0の場合だけ作用するようにcontrol qubitを追加</span></div><div class="line">    <span class="keyword">auto</span> x_mat_gate = gate::to_matrix_gate(x_gate);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> control_index = 1;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> control_with_value = 0;</div><div class="line">    x_mat_gate-&gt;add_control_qubit(control_index, control_with_value);</div><div class="line"></div><div class="line">    x_mat_gate-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> x_gate;</div><div class="line">    <span class="keyword">delete</span> x_mat_gate;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>専用の量子ゲートの一覧についてはAPIドキュメントをご覧ください。</p>
<h3>量子ゲートのゲート行列の取得</h3>
<p>生成した量子ゲートのゲート行列を取得できます。control量子ビットなどはゲート行列に含まれません。特にゲート行列を持たない種類のゲート（例えばn-qubitのパウリ回転ゲート）などは取得に非常に大きなメモリと時間を要するので気を付けてください。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> x_gate = gate::X(index);</div><div class="line"></div><div class="line">    <span class="comment">// 行列要素の取得</span></div><div class="line">    <span class="comment">// ComplexMatrixはEigen::MatrixXcdでRowMajorにした複素行列型</span></div><div class="line">    ComplexMatrix matrix;</div><div class="line">    x_gate-&gt;set_matrix(matrix);</div><div class="line">    std::cout &lt;&lt; matrix &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>量子ゲートの情報の取得</h3>
<p><code>ostream</code>に流し込むことで、量子ゲートのデバッグ情報を表示できます。量子ゲートのゲート行列が非常に巨大な場合、とても時間がかかるので注意してください。専用関数を持つ量子ゲートは自身のゲート行列は表示しません。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> x_gate = gate::X(index);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; x_gate &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">delete</span> x_gate;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>一般的な量子ゲートの実現</h3>
<p>cppsimでは量子情報における種々のマップを以下の形で実現します。</p>
<h4>ユニタリ操作</h4>
<p>量子ゲートとして実現します。</p>
<h4>射影演算子やクラウス演算子など</h4>
<p>量子ゲートとして実現します。一般に作用後に量子状態のノルムは保存されません。<code>DenseMatrix</code>関数により生成できます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_general.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    ComplexMatrix one_qubit_matrix(2, 2);</div><div class="line">    one_qubit_matrix &lt;&lt; 0, 1, 1, 0;</div><div class="line">    <span class="keyword">auto</span> one_qubit_gate = gate::DenseMatrix(0, one_qubit_matrix);</div><div class="line">    std::cout &lt;&lt; one_qubit_gate &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    ComplexMatrix two_qubit_matrix(4,4);</div><div class="line">    two_qubit_matrix &lt;&lt;</div><div class="line">        1, 0, 0, 0,</div><div class="line">        0, 1, 0, 0,</div><div class="line">        0, 0, 0, 1,</div><div class="line">        0, 0, 1, 0;</div><div class="line">    <span class="keyword">auto</span> two_qubit_gate = gate::DenseMatrix({0,1}, two_qubit_matrix);</div><div class="line">    std::cout &lt;&lt; two_qubit_gate &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4>確率的なユニタリ操作</h4>
<p><code>Probabilistic</code>関数を用いて、複数のユニタリ操作と確率分布を与えて作成します。 </p><div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_general.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> x_gate = gate::X(index);</div><div class="line">    <span class="keyword">auto</span> z_gate = gate::Z(index);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> probabilistic_xz_gate = gate::Probabilistic({ x_gate,z_gate }, { 0.1,0.2 });</div><div class="line">    <span class="keyword">auto</span> depolarizing_gate = gate::DepolarizingNoise(0.3);</div><div class="line"></div><div class="line">    depolarizing_gate-&gt;update_quantum_state(&amp;state);</div><div class="line">    probabilistic_xz_gate-&gt;update_quantum_state(&amp;state);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4>CPTP-map</h4>
<p><code>CPTP</code>関数に完全性を満たすクラウス演算子のリストとして与えて作成します。 </p><div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_general.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> p0 = gate::P0(index);</div><div class="line">    <span class="keyword">auto</span> p1_fix = gate::merge(gate::P1(index), gate::X(index));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> correction = gate::CPTP({p0,p1_fix});</div><div class="line">    <span class="keyword">auto</span> noise = gate::BitFlipNoise(index,0.1);</div><div class="line"></div><div class="line">    noise-&gt;update_quantum_state(&amp;state);</div><div class="line">    correction-&gt;update_quantum_state(&amp;state);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4>POVM</h4>
<p>数値計算上にはInstrumentと同じなので、Instrumentとして実現します。</p>
<h4>Instrument</h4>
<p>Instrumentは一般のCPTP-mapの操作に加え、ランダムに作用したクラウス演算子の添え字を取得する操作です。例えば、Z基底での測定は<code>P0</code>と<code>P1</code>からなるCPTP-mapを作用し、どちらが作用したかを知ることに相当します。 cppsimでは<code>Instrument</code>関数にCPTP-mapの情報と、作用したクラウス演算子の添え字を書きこむ古典レジスタのアドレスを指定することで実現します。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_general.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keyword">auto</span> gate00 = gate::merge(gate::P0(0), gate::P0(1));</div><div class="line">    <span class="keyword">auto</span> gate01 = gate::merge(gate::P0(0), gate::P1(1));</div><div class="line">    <span class="keyword">auto</span> gate10 = gate::merge(gate::P1(0), gate::P0(1));</div><div class="line">    <span class="keyword">auto</span> gate11 = gate::merge(gate::P1(0), gate::P1(1));</div><div class="line"></div><div class="line">    std::vector&lt;QuantumGateBase*&gt; gate_list = { gate00, gate01, gate10, gate11 };</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> classical_pos = 0;</div><div class="line">    <span class="keyword">auto</span> gate = gate::Instrument(gate_list, classical_pos);</div><div class="line"></div><div class="line">    QuantumState state(2);</div><div class="line">    state.set_Haar_random_state();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; state &lt;&lt; std::endl;</div><div class="line">    gate-&gt;update_quantum_state(&amp;state);</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result = state.get_classical_value(classical_pos);</div><div class="line">    std::cout &lt;&lt; state &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4>Adaptive</h4>
<p>古典レジスタに書き込まれた値に応じて操作を行ったり行わなかったりします。cppsimでは<code>[unsigned int]</code>型のレジスタを引数として受け取り、<code>bool</code>型を返す関数を指定し、これを実現します。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_merge.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_matrix.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_general.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 3;</div><div class="line">    <span class="keyword">auto</span> h = gate::H(index);</div><div class="line">    h-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> meas = gate::Measurement(index,0);</div><div class="line">    meas-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> condition = [](<span class="keyword">const</span> std::vector&lt;UINT&gt; reg){</div><div class="line">        <span class="keywordflow">return</span> reg[0]==1;</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> correction = gate::Adaptive(gate::X(index), condition);</div><div class="line">    correction-&gt;update_quantum_state(&amp;state);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h4>CP-map</h4>
<p>Kraus-rankが1の場合は、上記の単体のクラウス演算子として扱ってください。それ以外の場合は、TPになるようにクラウス演算子を調整した後、<code>multiply_scalar</code>関数で定数倍にした<code>Identity</code>オペレータを作用するなどして調整してください。</p>
<h2>量子回路</h2>
<h3>量子回路の構成</h3>
<p>量子回路は量子ゲートの集合として表されます。 例えば以下のように量子回路を構成できます。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/circuit.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    QuantumState state(n);</div><div class="line">    state.set_zero_state();</div><div class="line"></div><div class="line">    <span class="comment">// 量子回路を定義</span></div><div class="line">    QuantumCircuit circuit(n);</div><div class="line"></div><div class="line">    <span class="comment">// 量子回路にゲートを追加</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;n;++i){</div><div class="line">        circuit.add_H_gate(i);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 自身で定義したゲートも追加できる</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;n;++i){</div><div class="line">        circuit.add_gate(gate::H(i));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 量子回路を状態に作用</span></div><div class="line">    circuit.update_quantum_state(&amp;state);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>なお、<code>add_gate</code>で追加された量子回路は量子回路の解放時に一緒に解放されます。従って、代入したゲートは再利用できません。 引数として与えたゲートを再利用したい場合は、<code>add_gate_copy</code>関数を用いてください。ただしこの場合自身でゲートを解放する必要があります。</p>
<h3>量子回路の最適化</h3>
<p>量子ゲートをまとめて一つの量子ゲートとすることで、量子ゲートの数を減らすことができ、数値計算の時間を短縮できることがあります。（もちろん、対象となる量子ビットの数が増える場合や、専用関数を持つ量子ゲートを合成して専用関数を持たない量子ゲートにしてしまった場合は、トータルで計算時間が減少するかは状況に依ります。）</p>
<p>下記のコードでは<code>optimize</code>関数を用いて、量子回路の量子ゲートをターゲットとなる量子ビットが3つになるまで貪欲法で合成を繰り返します。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/circuit.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/circuit_optimizer.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depth = 10;</div><div class="line">    QuantumCircuit circuit(n);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = 0; d &lt; depth; ++d) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div><div class="line">            circuit.add_gate(gate::H(i));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 量子回路の最適化</span></div><div class="line">    QuantumCircuitOptimizer opt;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_block_size = 3;</div><div class="line">    opt.optimize(&amp;circuit, max_block_size);</div><div class="line">    <span class="keywordflow">return</span> 0;</div></div><!-- fragment --><h3>量子回路の情報デバッグ</h3>
<p>量子ゲートと同様、量子回路も<code>ostream</code>に流し込むことでデバッグ情報を表示することができます。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/gate_factory.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/circuit.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> depth = 10;</div><div class="line">    QuantumCircuit circuit(n);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d = 0; d &lt; depth; ++d) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div><div class="line">            circuit.add_gate(gate::H(i));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// 量子回路の情報を出力</span></div><div class="line">    std::cout &lt;&lt; circuit &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>オブザーバブル</h2>
<h3>オブザーバブルの生成</h3>
<p>オブザーバブルはパウリ演算子の集合として表現されます。 パウリ演算子は下記のように定義できます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/observable.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    <span class="keywordtype">double</span> coef = 2.0;</div><div class="line">    std::string Pauli_string = <span class="stringliteral">&quot;X 0 X 1 Y 2 Z 4&quot;</span>;</div><div class="line">    Observable observable(n);</div><div class="line">    observable.add_operator(coef,Pauli_string.c_str());</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>OpenFermionとの連携</h3>
<p>また、OpenFermionを用いて生成された以下のようなフォーマットのファイルから, オブザーバブルを生成することができます。このとき、オブザーバブルはそれを構成するのに必要最小限の大きさとなります。例えば、以下のようなopenfermionを用いて得られたオブザーバブルを読み込み、オブザーバブルを生成することが可能です。 </p><div class="fragment"><div class="line">from openfermion.ops import FermionOperator</div><div class="line">from openfermion.transforms import bravyi_kitaev</div><div class="line"></div><div class="line">h_00 = h_11 = -1.252477</div><div class="line">h_22 = h_33 = -0.475934</div><div class="line">h_0110 = h_1001 = 0.674493</div><div class="line">h_2332 = h_3323 = 0.697397</div><div class="line">h_0220 = h_0330 = h_1221 = h_1331 = h_2002 = h_3003 = h_2112 = h_3113 = 0.663472</div><div class="line">h_0202 = h_1313 = h_2130 = h_2310 = h_0312 = h_0132 = 0.181287</div><div class="line"></div><div class="line">fermion_operator = FermionOperator(&#39;0^ 0&#39;, h_00)</div><div class="line">fermion_operator += FermionOperator(&#39;1^ 1&#39;, h_11)</div><div class="line">fermion_operator += FermionOperator(&#39;2^ 2&#39;, h_22)</div><div class="line">fermion_operator += FermionOperator(&#39;3^ 3&#39;, h_33)</div><div class="line"></div><div class="line">fermion_operator += FermionOperator(&#39;0^ 1^ 1 0&#39;, h_0110)</div><div class="line">fermion_operator += FermionOperator(&#39;2^ 3^ 3 2&#39;, h_2332)</div><div class="line">fermion_operator += FermionOperator(&#39;0^ 3^ 3 0&#39;, h_0330)</div><div class="line">fermion_operator += FermionOperator(&#39;1^ 2^ 2 1&#39;, h_1221)</div><div class="line"></div><div class="line">fermion_operator += FermionOperator(&#39;0^ 2^ 2 0&#39;, h_0220-h_0202)</div><div class="line">fermion_operator += FermionOperator(&#39;1^ 3^ 3 1&#39;, h_1331-h_1313)</div><div class="line"></div><div class="line">fermion_operator += FermionOperator(&#39;0^ 1^ 3 2&#39;, h_0132)</div><div class="line">fermion_operator += FermionOperator(&#39;2^ 3^ 1 0&#39;, h_0132)</div><div class="line"></div><div class="line">fermion_operator += FermionOperator(&#39;0^ 3^ 1 2&#39;, h_0312)</div><div class="line">fermion_operator += FermionOperator(&#39;2^ 1^ 3 0&#39;, h_0312)</div><div class="line"></div><div class="line">## Bravyi-Kitaev transformation</div><div class="line">bk_operator = bravyi_kitaev(fermion_operator)</div><div class="line"></div><div class="line">## output</div><div class="line">fp = open(&quot;H2.txt&quot;, &#39;w&#39;)</div><div class="line">fp.write(str(bk_operator))</div><div class="line">fp.close()</div></div><!-- fragment --><p> このとき、上のpythonコードで生成された<code>H2.txt</code>ファイルは以下のような形式になっています。 </p><div class="fragment"><div class="line">(-0.8126100000000005+0j) [] +</div><div class="line">(0.04532175+0j) [X0 Z1 X2] +</div><div class="line">(0.04532175+0j) [X0 Z1 X2 Z3] +</div><div class="line">(0.04532175+0j) [Y0 Z1 Y2] +</div><div class="line">(0.04532175+0j) [Y0 Z1 Y2 Z3] +</div><div class="line">(0.17120100000000002+0j) [Z0] +</div><div class="line">(0.17120100000000002+0j) [Z0 Z1] +</div><div class="line">(0.165868+0j) [Z0 Z1 Z2] +</div><div class="line">(0.165868+0j) [Z0 Z1 Z2 Z3] +</div><div class="line">(0.12054625+0j) [Z0 Z2] +</div><div class="line">(0.12054625+0j) [Z0 Z2 Z3] +</div><div class="line">(0.16862325+0j) [Z1] +</div><div class="line">(-0.22279649999999998+0j) [Z1 Z2 Z3] +</div><div class="line">(0.17434925+0j) [Z1 Z3] +</div><div class="line">(-0.22279649999999998+0j) [Z2]</div></div><!-- fragment --><p> このような形式のファイルからオブザーバブルを生成するには、以下のようにコンストラクタの引数にファイルのパスを渡してやります。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/observable.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    std::string filename = <span class="stringliteral">&quot;H2.txt&quot;</span>;</div><div class="line">    Observable observable(filename);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h3>オブザーバブルの評価</h3>
<p>状態に対してオブザーバブルの期待値を評価できます。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/observable.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 5;</div><div class="line">    <span class="keywordtype">double</span> coef = 2.0;</div><div class="line">    std::string Pauli_string = <span class="stringliteral">&quot;X 0 X 1 Y 2 Z 4&quot;</span>;</div><div class="line">    Observable observable(n);</div><div class="line">    observable.add_operator(coef, Pauli_string.c_str());</div><div class="line">    </div><div class="line">    QuantumState state(n);</div><div class="line">    observable.get_expectation_value(&amp;state);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>### オブザーバブルの回転 オブザーバブル <img class="formulaInl" alt="$H$" src="form_3.png"/>の回転 <img class="formulaInl" alt="$e^{i\theta H}$" src="form_4.png"/>をTrotter展開によって行います。<code>num_repeats</code>はデフォルト値では以下のコードのようになっていますが、ユーザがオプションで指定することが可能です。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/circuit.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/observable.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    UINT n;</div><div class="line">    UINT num_repeats;</div><div class="line">    <span class="keywordtype">double</span> theta;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> res;</div><div class="line"></div><div class="line">    Observable observable(<span class="stringliteral">&quot;../test/cppsim/H2.txt&quot;</span>); </div><div class="line">    </div><div class="line">    n = observable.get_qubit_count();</div><div class="line">    QuantumState state(n);  </div><div class="line">    state.set_computational_basis(0);</div><div class="line">    </div><div class="line">    QuantumCircuit circuit(n);</div><div class="line">    num_repeats = (UINT) std::ceil(theta * (<span class="keywordtype">double</span>)n* 100.);</div><div class="line">    circuit.add_hamiltonian_rotation_gate(observable, angle, num_repeats);</div><div class="line">    circuit.update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    res = observable.get_expectation_value(&amp;state);</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>変分量子回路</h2>
<p>量子回路をParametricQuantumCircuitクラスとして定義すると、通所のQuantumCircuitクラスの関数に加え、変分法を用いて量子回路を最適化するのに便利ないくつかの関数を利用することができます。</p>
<h3>変分量子回路の利用例</h3>
<p>一つの回転角を持つ量子ゲート(X-rot, Y-rot, Z-rot, multi_qubit_pauli_rotation)はパラメトリックな量子ゲートとして量子回路に追加することができます。パラメトリックなゲートとして追加された量子ゲートについては、量子回路の構成後にパラメトリックなゲート数を取り出したり、後から回転角を変更することができます。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cppsim/state.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vqcsim/parametric_circuit.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cppsim/utility.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(){</div><div class="line">    <span class="keyword">const</span> UINT n = 3;</div><div class="line">    <span class="keyword">const</span> UINT depth = 10;</div><div class="line"></div><div class="line">    <span class="comment">// create n-qubit parametric circuit</span></div><div class="line">    ParametricQuantumCircuit* circuit = <span class="keyword">new</span> ParametricQuantumCircuit(n);</div><div class="line">    Random random;</div><div class="line">    <span class="keywordflow">for</span> (UINT d = 0; d &lt; depth; ++d) {</div><div class="line">        <span class="comment">// add parametric X,Y,Z gate with random initial rotation angle</span></div><div class="line">        <span class="keywordflow">for</span> (UINT i = 0; i &lt; n; ++i) {</div><div class="line">            circuit-&gt;add_parametric_RX_gate(i, random.uniform());</div><div class="line">            circuit-&gt;add_parametric_RY_gate(i, random.uniform());</div><div class="line">            circuit-&gt;add_parametric_RZ_gate(i, random.uniform());</div><div class="line">        }</div><div class="line">        <span class="comment">// add neighboring two-qubit ZZ rotation</span></div><div class="line">        <span class="keywordflow">for</span> (UINT i = d % 2; i + 1 &lt; n; i+=2) {</div><div class="line">            circuit-&gt;add_parametric_multi_Pauli_rotation_gate({ i,i + 1 }, { 3,3 }, random.uniform());</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// get parameter count</span></div><div class="line">    UINT param_count = circuit-&gt;get_parameter_count();</div><div class="line"></div><div class="line">    <span class="comment">// get current parameter, and set shifted parameter</span></div><div class="line">    <span class="keywordflow">for</span> (UINT p = 0; p &lt; param_count; ++p) {</div><div class="line">        <span class="keywordtype">double</span> current_angle = circuit-&gt;get_parameter(p);</div><div class="line">        circuit-&gt;set_parameter(p, current_angle + random.uniform());</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// create quantum state and update</span></div><div class="line">    QuantumState state(n);</div><div class="line">    circuit-&gt;update_quantum_state(&amp;state);</div><div class="line"></div><div class="line">    <span class="comment">// output state and circuit info</span></div><div class="line">    std::cout &lt;&lt; state &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; circuit &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// release quantum circuit</span></div><div class="line">    <span class="keyword">delete</span> circuit;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
